# Медицинский Архив Контроля Анализов и Клинических Актов "МАКАКА"

### Запуск:
```sh
bash launch.sh
```

## Что делает система:

- управление различными видами животных
- сотрудников зоопарка с различными обязанностями
- операции по уходу: кормление, медицинские осмотры, уборка вольеров
- генерацию отчетов о состоянии животных и расписании кормления

## Применение принципов SOLID

### Single Responsibility Principle

Каждый класс имеет единственную ответственность:

- **Animal** и его подклассы - отвечают только за хранение информации о животном и его базовом поведении (звук, тип еды)
- **Keeper** - отвечает исключительно за кормление животных
- **Veterinarian** - отвечает только за медицинские осмотры и лечение
- **Cleaner** - отвечает только за уборку вольеров
- **ReportGenerator** - отвечает только за формирование отчетов

Изменения в логике кормления не затрагивают код лечения, а изменения в отчетах не влияют на операции ухода за животными.

### Open/Closed Principle

Система открыта для расширения, но закрыта для модификации:

- для добавления нового вида животного создаем класс `Tiger extends Animal` без изменения существующих классов `Lion`, `Parrot`, `Snake` или других компонентов системы
- для добавления нового типа сотрудника (например, тренера) достаточно создать класс, реализующий соответствующий интерфейс (`Feedable`, `Treatable` или `Cleanable`), без изменения существующих классов сотрудников
- `ReportGenerator` работает с абстракцией `Animal`, поэтому автоматически поддерживает все новые виды животных без изменений

### Liskov Substitution Principle

Все подклассы `Animal` могут использоваться везде, где ожидается базовый класс:

- `Lion`, `Parrot`, `Snake` могут быть подставлены вместо `Animal` в любом месте кода
- все подклассы нормально реализуют методы `makeSound()` и `getFoodType()`, сохраняя контракт базового класса
- в `ReportGenerator.generateReport()` и при работе сотрудников можно использовать любой подкласс `Animal` без нарушения функциональности

### Interface Segregation Principle

Интерфейсы разделены на узконаправленные контракты:

- **Feedable** - содержит только метод `feed()`, используется смотрителями
- **Treatable** - содержит методы `treat()` и `checkHealth()`, используется ветеринарами
- **Cleanable** - содержит только метод `clean()`, используется уборщиками

Классы сотрудников реализуют только те интерфейсы, которые им реально нужны:
- `Keeper` реализует только `Feedable`, не вынужден реализовывать ненужные методы лечения или уборки
- `Veterinarian` реализует только `Treatable`, не содержит методов кормления
- `Cleaner` реализует только `Cleanable`

Позволяет избежать пустых реализаций методов и делает код понятным.

### Dependency Inversion Principle

Высокоуровневые модули зависят от абстракций, а не от конкретных реализаций:

- классы сотрудников (`Keeper`, `Veterinarian`, `Cleaner`) зависят от интерфейсов (`Feedable`, `Treatable`, `Cleanable`), а не от конкретных классов животных
- `ReportGenerator` зависит от абстракции `Animal`, а не от конкретных классов `Lion`, `Parrot`, `Snake`
- в `Main` можно работать с коллекцией `List<Animal>`, используя полиморфизм

Благодаря этому можно легко заменять реализации (например, создать `AdvancedKeeper` с улучшенной логикой кормления) без изменения зависимых модулей.

## Когда могут появиться проблемы добавления нового функционала или расширении бизнес-логики

1. **Добавление новых операций ухода**: Если потребуется добавить новую операцию (например, тренировка животных), потребуется создать новый интерфейс и обновить существующие классы сотрудников, если они должны поддерживать эту операцию. Однако это не нарушает OCP, так как можно создать новый класс сотрудника, реализующий новый интерфейс.

2. **Сложная логика отчетов**: Если потребуется генерировать отчеты в разных форматах (XML, JSON, PDF), текущий `ReportGenerator` может потребовать рефакторинга. Решение - применить Strategy pattern для разных форматов вывода.

3. **Управление расписанием**: Текущая система не управляет расписанием кормления. Добавление этой функциональности может потребовать создания новых классов для управления временем, но не нарушит существующую архитектуру.

4. **Вольеры**: Система не моделирует вольеры явно. Добавление этой сущности может потребовать создания класса `Enclosure` и связи его с животными, но это расширение, а не изменение.

## Почему введенные абстракции улучшили качество дизайна

1. **Расширяемость**: Легко добавлять новые виды животных и типы сотрудников без изменения существующего кода, что снижает риск внесения ошибок.

2. **Тестируемость**: Интерфейсы позволяют создавать mock-объекты для тестирования, изолируя компоненты системы.

3. **Читаемость**: Четкое разделение ответственности делает код понятным - сразу видно, кто за что отвечает.

4. **Гибкость**: Полиморфизм позволяет работать с коллекциями животных единообразно, не зная конкретных типов.

5. **Поддерживаемость**: Изменения в одном компоненте (например, логика кормления) не затрагивают другие компоненты (лечение, уборка), что упрощает сопровождение кода.

6. **Переиспользование**: Интерфейсы можно использовать для создания новых типов сотрудников с комбинированными обязанностями (например, `KeeperVeterinarian`, реализующй и `Feedable`, и `Treatable`).

